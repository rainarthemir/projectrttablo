const GTFS_BASE = "https://rainarthemir.github.io/projectrttablo/gtfs/";
const FILES = [
  "stops.txt",
  "routes.txt",
  "trips.txt",
  "stop_times.txt",
  "calendar.txt"
];

// ---------------- CSV PARSER ----------------
function parseCsv(text, keyField) {
  const lines = text.replace(/\r/g, "").split("\n").filter(l => l.trim().length > 0);
  if (!lines.length) return keyField ? {} : [];
  const headers = lines.shift().split(",");
  const result = keyField ? {} : [];
  for (const line of lines) {
    const values = line.split(",");
    const obj = {};
    for (let i = 0; i < headers.length; i++) obj[headers[i]] = values[i] ?? "";
    if (keyField) { if (obj[keyField]) result[obj[keyField]] = obj; } else { result.push(obj); }
  }
  return result;
}

// ---------------- LOAD + PARSE GTFS ----------------
async function loadAndParseGtfs() {
  const raw = {};
  for (const file of FILES) {
    const res = await fetch(GTFS_BASE + file, { cf: { cacheTtl: 0 } });
    if (!res.ok) throw new Error(`Failed to load ${file} (${res.status})`);
    raw[file] = await res.text();
  }

  return {
    loadedAt: Date.now(),
    source: "github",
    stops: parseCsv(raw["stops.txt"], "stop_id"),
    routes: parseCsv(raw["routes.txt"], "route_id"),
    trips: parseCsv(raw["trips.txt"], "trip_id"),
    stopTimes: parseCsv(raw["stop_times.txt"], null),
    calendar: parseCsv(raw["calendar.txt"], "service_id")
  };
}

// ---------------- HELPERS ----------------
function timeToMinutes(hhmmss) {
  const [h, m] = hhmmss.split(":").map(Number);
  return h * 60 + m;
}

function addMinutes(timeStr, minutes) {
  let [h, m, s] = timeStr.split(":").map(Number);
  let total = h * 60 + m + minutes;
  if (total < 0) total = 0;
  h = Math.floor(total / 60) % 24;
  m = total % 60;
  return `${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}:${s.toString().padStart(2,"0")}`;
}

function getParisMinutes() {
  const nowUTC = new Date();
  const parisNow = new Date(nowUTC.toLocaleString("en-US", { timeZone: "Europe/Paris" }));
  return parisNow.getHours() * 60 + parisNow.getMinutes();
}

// ---------------- DATE FORMAT HELPERS ----------------
function convertDateToYYYYMMDD(dateStr) {
  // Если дата в формате DDMMYYYY (8 цифр)
  if (dateStr.length === 8 && /^\d{8}$/.test(dateStr)) {
    const day = dateStr.substring(0, 2);
    const month = dateStr.substring(2, 4);
    const year = dateStr.substring(4);
    // Проверяем, является ли это валидной датой DDMMYYYY
    if (parseInt(day) >= 1 && parseInt(day) <= 31 && 
        parseInt(month) >= 1 && parseInt(month) <= 12) {
      return year + month + day; // Конвертируем в YYYYMMDD
    }
  }
  // Если дата в формате YYYYMMDD (уже правильный формат)
  if (dateStr.length === 8 && /^\d{8}$/.test(dateStr)) {
    return dateStr;
  }
  return dateStr;
}

function getTodayDate() {
  const nowUTC = new Date();
  const parisNow = new Date(nowUTC.toLocaleString("en-US", { timeZone: "Europe/Paris" }));
  const year = parisNow.getFullYear();
  const month = String(parisNow.getMonth() + 1).padStart(2, '0');
  const day = String(parisNow.getDate()).padStart(2, '0');
  return year + month + day; // YYYYMMDD
}

async function getRtData(kv, date) {
  const formattedDate = convertDateToYYYYMMDD(date);
  const data = await kv.get(`rt_data_${formattedDate}`, { type: "json" });
  return data || {};
}

async function setRtData(kv, date, newData) {
  const formattedDate = convertDateToYYYYMMDD(date);
  await kv.put(`rt_data_${formattedDate}`, JSON.stringify(newData));
}

// ---------------- APPLY RT CHANGES ----------------
function applyRtChanges(tripId, allStopTimes, rtDataTrip) {
  // Получаем все остановки этого рейса
  const tripStopTimes = allStopTimes.filter(st => st.trip_id === tripId);
  if (!tripStopTimes.length) return tripStopTimes;
  
  // Сортируем остановки по stop_sequence
  const sortedStops = [...tripStopTimes].sort((a, b) => {
    return parseInt(a.stop_sequence) - parseInt(b.stop_sequence);
  });
  
  // Определяем последнюю остановку
  const lastStop = sortedStops[sortedStops.length - 1];
  const lastStopId = lastStop ? lastStop.stop_id : null;
  
  // Если весь рейс отменен
  if (rtDataTrip?.canceled === true) {
    return sortedStops.map(st => ({
      ...st, 
      amended_departure: st.departure_time, 
      amended_arrival: st.arrival_time, 
      amended: true, 
      status: "canceled",
      is_last: st.stop_id === lastStopId
    }));
  }
  
  let stops = [];
  let cumulativeDelay = 0; // Накопительная задержка
  let propagateActive = false;
  
  for (const st of sortedStops) {
    const changes = rtDataTrip?.stop_times?.[st.stop_id] || null;
    let amendedDeparture = st.departure_time;
    let amendedArrival = st.arrival_time;
    let status = "on_time";
    let amended = false;

    // Обрабатываем изменения
    if (changes) {
      amended = true;
      
      if (changes.action === "delay") {
        const delta = Number(changes.minutes || 0);
        cumulativeDelay += delta; // Добавляем задержку к накопительной
        amendedDeparture = addMinutes(st.departure_time, cumulativeDelay);
        amendedArrival = addMinutes(st.arrival_time, cumulativeDelay);
        status = "delayed";
        
        // Если propagate = true, включаем распространение
        if (changes.propagate === true) {
          propagateActive = true;
        } else {
          propagateActive = false;
          cumulativeDelay = 0; // Сбрасываем для следующей остановки если без распространения
        }
      } else if (changes.action === "earlify") {
        const delta = Number(changes.minutes || 0);
        cumulativeDelay -= delta; // Вычитаем из накопительной задержки (отрицательное значение)
        amendedDeparture = addMinutes(st.departure_time, cumulativeDelay);
        amendedArrival = addMinutes(st.arrival_time, cumulativeDelay);
        status = "early";
        
        // Если propagate = true, включаем распространение
        if (changes.propagate === true) {
          propagateActive = true;
        } else {
          propagateActive = false;
          cumulativeDelay = 0; // Сбрасываем для следующей остановки если без распространения
        }
      } else if (changes.action === "cancel") {
        // При отмене оставляем время без изменений, но ставим статус canceled
        amendedDeparture = st.departure_time;
        amendedArrival = st.arrival_time;
        status = "canceled";
        propagateActive = false; // Отмена не распространяется
        cumulativeDelay = 0; // Сбрасываем накопительную задержку
      }
    } else if (propagateActive && cumulativeDelay !== 0) {
      // Применяем накопительную задержку к этой остановке (распространение)
      amended = true;
      amendedDeparture = addMinutes(st.departure_time, cumulativeDelay);
      amendedArrival = addMinutes(st.arrival_time, cumulativeDelay);
      status = cumulativeDelay > 0 ? "delayed" : "early";
    }

    stops.push({ 
      ...st, 
      amended_departure: amendedDeparture, 
      amended_arrival: amendedArrival, 
      amended, 
      status,
      is_last: st.stop_id === lastStopId
    });
  }

  // Вставляем stop_exception после указанных стопов
  if (rtDataTrip?.stop_exceptions?.length) {
    // Сортируем исключения по after_stop_sequence
    const sortedExceptions = [...rtDataTrip.stop_exceptions].sort((a, b) => {
      return parseInt(a.after_stop_sequence || "0") - parseInt(b.after_stop_sequence || "0");
    });
    
    for (const exc of sortedExceptions) {
      const index = stops.findIndex(s => s.stop_id === exc.after_stop_id);
      if (index !== -1) {
        stops.splice(index + 1, 0, {
          stop_id: exc.stop_id,
          stop_name: exc.stop_name || `New Stop ${exc.stop_id}`,
          arrival_time: exc.time,
          departure_time: exc.time,
          amended_arrival: exc.time,
          amended_departure: exc.time,
          amended: true,
          status: "on_time",
          is_last: false,
          stop_sequence: exc.after_stop_sequence ? (parseInt(exc.after_stop_sequence) + 0.5).toString() : "999"
        });
      }
    }
  }

  // Обновляем флаг is_last для новой последней остановки
  if (stops.length > 0) {
    // Сортируем по stop_sequence для правильного определения последней остановки
    stops.sort((a, b) => parseFloat(a.stop_sequence || "0") - parseFloat(b.stop_sequence || "0"));
    stops[stops.length - 1].is_last = true;
  }

  // НЕ фильтруем отмененные остановки - они должны оставаться в списке
  return stops;
}

// Определяем активные service_id на сегодня
function getActiveServiceIds(calendar) {
  const nowUTC = new Date();
  const parisNow = new Date(nowUTC.toLocaleString("en-US", { timeZone: "Europe/Paris" }));
  const dayOfWeek = parisNow.getDay(); // 0 - воскресенье, 1 - понедельник и т.д.
  const todayStr = getTodayDate(); // YYYYMMDD
  
  const activeServiceIds = [];
  
  // Маппинг дня недели для GTFS (monday=1, tuesday=2, ..., sunday=7)
  const gtfsDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  const todayGtfsDay = gtfsDays[dayOfWeek];
  
  for (const serviceId in calendar) {
    const service = calendar[serviceId];
    // Проверяем, что сегодняшняя дата в диапазоне действия service
    if (service.start_date <= todayStr && service.end_date >= todayStr) {
      // Проверяем, что service активен сегодня
      if (service[todayGtfsDay] === "1") {
        activeServiceIds.push(serviceId);
      }
    }
  }
  
  return activeServiceIds;
}

// ---------------- WORKER ----------------
export default {
  async fetch(req, env) {
    try {
      const url = new URL(req.url);
      const pathname = url.pathname.replace(/^\/|\/$/g, "");
      const pathParts = pathname.split("/");

      // Load GTFS
      let gtfs = await env.kv.get("gtfs_parsed", { type: "json" });
      if (!gtfs) {
        gtfs = await loadAndParseGtfs();
        await env.kv.put("gtfs_parsed", JSON.stringify(gtfs));
      }

      const nowMinutes = getParisMinutes();
      const activeServiceIds = getActiveServiceIds(gtfs.calendar);
      const activeServiceIdsSet = new Set(activeServiceIds);
      const todayDate = getTodayDate();

      // ---------------- STOP MONITORING ----------------
      if (pathParts[0] === "stop_monitoring" && pathParts.length >= 2) {
        const stop_id = pathParts[1];
        const mode = pathParts[2] || "departures";
        const quantity = Math.min(Number(url.searchParams.get("q") || 5), 100);
        const showCanceled = url.searchParams.get("show_canceled") === "true";
        const stopInfo = gtfs.stops[stop_id];
        if (!stopInfo) return new Response(JSON.stringify({ status: "error", message: "Stop not found" }, null, 2), { status:404, headers:{"content-type":"application/json"} });

        const rtData = await getRtData(env.kv, todayDate);

        // Получаем все stop_times для этой остановки
        let stopTimes = gtfs.stopTimes.filter(st => st.stop_id === stop_id);
        
        // Обрабатываем каждый stop_time
        const processedStopTimes = [];
        
        for (const st of stopTimes) {
          const trip = gtfs.trips[st.trip_id];
          if (!trip) continue;
          
          // Проверяем, что рейс активен сегодня
          if (!activeServiceIdsSet.has(trip.service_id)) continue;
          
          const route = gtfs.routes[trip.route_id] || {};
          
          // Применяем RT изменения для всего рейса
          const allTripStops = applyRtChanges(st.trip_id, gtfs.stopTimes, rtData[st.trip_id] || {});
          
          // Находим нашу остановку в обработанном списке
          const processedStop = allTripStops.find(s => s.stop_id === stop_id);
          if (!processedStop) continue;
          
          // Находим последнюю остановку рейса
          const tripAllStops = gtfs.stopTimes.filter(x => x.trip_id === st.trip_id);
          const lastStop = tripAllStops.length > 0 ? tripAllStops[tripAllStops.length - 1] : null;
          const tripHeadsign = lastStop ? gtfs.stops[lastStop.stop_id]?.stop_name || "" : "";
          
          processedStopTimes.push({
            ...processedStop,
            trip_id: st.trip_id,
            route_id: trip.route_id,
            route_name: route.route_short_name || route.route_long_name,
            route_color: route.route_color || "",
            route_text_color: route.route_text_color || "",
            trip_headsign: tripHeadsign,
            stop_name: gtfs.stops[stop_id]?.stop_name || "",
            service_id: trip.service_id
          });
        }
        
        // Сортируем по времени
        processedStopTimes.sort((a, b) => {
          const timeA = timeToMinutes(mode === "arrivals" ? a.amended_arrival : a.amended_departure);
          const timeB = timeToMinutes(mode === "arrivals" ? b.amended_arrival : b.amended_departure);
          return timeA - timeB;
        });

        let result;
        if (mode === "arrivals") {
          // Показываем ближайшие прибытия
          result = processedStopTimes.filter(st => 
            timeToMinutes(st.amended_arrival) >= nowMinutes || 
            (showCanceled && st.status === "canceled")
          ).slice(0, quantity);
        } else {
          // Для отправлений исключаем последнюю остановку (там нет отправления)
          result = processedStopTimes.filter(st => 
            (!st.is_last && timeToMinutes(st.amended_departure) >= nowMinutes) ||
            (showCanceled && st.status === "canceled" && !st.is_last)
          ).slice(0, quantity);
        }

        return new Response(JSON.stringify({ 
          status: "ok", 
          stop: stopInfo, 
          stop_id, 
          mode, 
          today_date: todayDate,
          count: result.length, 
          departures: result 
        }, null, 2), { 
          headers: {
            "content-type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Cache-Control": "no-store"
          } 
        });
      }

      // ---------------- TRIPS ----------------
      if (pathParts[0] === "trips" && pathParts.length === 1) {
        const rtData = await getRtData(env.kv, todayDate);
        
        // Фильтруем рейсы, активные сегодня
        const activeTrips = Object.values(gtfs.trips)
          .filter(trip => activeServiceIdsSet.has(trip.service_id));
        
        const tripsList = activeTrips.map(trip => {
          const tripStops = gtfs.stopTimes.filter(st => st.trip_id === trip.trip_id);
          if (!tripStops.length) return null;
          
          const firstDeparture = timeToMinutes(tripStops[0].departure_time);
          const lastArrival = timeToMinutes(tripStops[tripStops.length - 1].arrival_time);
          
          // Проверяем RT статус
          const rtTripData = rtData[trip.trip_id] || {};
          let status = "on_time";
          
          // Проверяем, есть ли отмененные остановки в этом рейсе
          if (rtTripData.canceled === true) {
            status = "canceled";
          } else if (rtTripData.stop_times) {
            const canceledStops = Object.values(rtTripData.stop_times).filter(st => st.action === "cancel");
            if (canceledStops.length > 0) {
              status = "partially_canceled";
            }
          }
          
          const nextStopObj = tripStops.find(st => timeToMinutes(st.departure_time) >= nowMinutes);
          const nextStop = nextStopObj ? gtfs.stops[nextStopObj.stop_id]?.stop_name || "" : null;
          const route = gtfs.routes[trip.route_id] || {};
          
          return { 
            trip_id: trip.trip_id, 
            route_id: trip.route_id,
            route_name: route.route_short_name || route.route_long_name,
            from: gtfs.stops[tripStops[0].stop_id]?.stop_name || "", 
            to: gtfs.stops[tripStops[tripStops.length - 1].stop_id]?.stop_name || "", 
            next_stop: nextStop, 
            status: status 
          };
        }).filter(Boolean);

        return new Response(JSON.stringify({ 
          status: "ok", 
          count: tripsList.length, 
          today_date: todayDate,
          trips: tripsList 
        }, null, 2), { 
          headers: {
            "content-type": "application/json",
            "Access-Control-Allow-Origin": "*"
          } 
        });
      }

      // ---------------- TRIP DETAIL ----------------
      if (pathParts[0] === "trips" && pathParts.length >= 2) {
        const trip_id = pathParts[1];
        const mode = pathParts[2] || "realtime";
        const trip = gtfs.trips[trip_id];
        if (!trip) return new Response(JSON.stringify({status: "error", message: "Trip not found"}, null, 2), {status:404, headers:{"content-type":"application/json"}});

        let tripStops = gtfs.stopTimes.filter(st => st.trip_id === trip_id);
        const rtData = await getRtData(env.kv, todayDate);
        
        if (mode === "realtime") {
          tripStops = applyRtChanges(trip_id, tripStops, rtData[trip_id] || {});
        } else {
          // Для non-realtime режима просто добавляем флаги
          const lastStop = tripStops.length > 0 ? tripStops[tripStops.length - 1] : null;
          tripStops = tripStops.map(st => ({
            ...st,
            amended_departure: st.departure_time,
            amended_arrival: st.arrival_time,
            amended: false,
            status: "on_time",
            is_last: st.stop_id === (lastStop ? lastStop.stop_id : null)
          }));
        }

        const firstDeparture = timeToMinutes(tripStops[0]?.departure_time || "00:00:00");
        const lastArrival = timeToMinutes(tripStops[tripStops.length - 1]?.arrival_time || "00:00:00");
        const tripStatus = nowMinutes < firstDeparture ? "future" : nowMinutes > lastArrival ? "past" : "current";
        const nextStopObj = tripStops.find(st => timeToMinutes(st.amended_departure) >= nowMinutes);
        const nextStop = nextStopObj ? nextStopObj.stop_name : null;
        const route = gtfs.routes[trip.route_id] || {};

        // Добавляем названия остановок
        const stopsWithNames = tripStops.map(st => ({
          ...st,
          stop_name: gtfs.stops[st.stop_id]?.stop_name || st.stop_name || `Stop ${st.stop_id}`
        }));

        return new Response(JSON.stringify({
          status: "ok",
          trip_id,
          route_id: trip.route_id,
          route_name: route.route_short_name || route.route_long_name,
          operator: route.route_desc || "",
          trip_status: tripStatus,
          today_date: todayDate,
          next_stop: nextStop,
          stops: stopsWithNames
        }, null, 2), { 
          headers: {
            "content-type": "application/json",
            "Access-Control-Allow-Origin": "*"
          } 
        });
      }

      // ---------------- RTEDIT ----------------
      if (pathParts[0] === "rtedit") {
        const passwordParam = pathParts[1];
        if (!passwordParam || passwordParam !== env.password) {
          return new Response(JSON.stringify({status: "error", message: "Access denied"}, null, 2), {status:403, headers:{"content-type":"application/json"}});
        }

        if (pathParts.length === 2) {
          return new Response(JSON.stringify({
            status: "ok", 
            network_status: "operational", 
            last_updated: new Date().toISOString(), 
            message: "Realtime editing ready",
            today_date: todayDate
          }, null, 2), {
            headers: {
              "content-type": "application/json",
              "Access-Control-Allow-Origin": "*"
            }
          });
        }

        if (pathParts[2] === "edit") {
          const dateInput = pathParts[3];
          const tripId = pathParts[5];
          const actionType = pathParts[6];
          const rtData = await getRtData(env.kv, dateInput);
          const onlyFlag = url.searchParams.get("only") === "true";

          // Отмена/восстановление всего рейса
          if (actionType === "cancel" || actionType === "normalize") {
            rtData[tripId] = rtData[tripId] || {stop_times: {}, stop_exceptions: []};
            
            if (actionType === "cancel") {
              rtData[tripId].canceled = true;
              await setRtData(env.kv, dateInput, rtData);
              return new Response(JSON.stringify({
                status: "ok", 
                trip_id: tripId, 
                action: "cancel",
                message: "Trip canceled for this date",
                date_input: dateInput,
                date_used: convertDateToYYYYMMDD(dateInput)
              }, null, 2), {
                headers: {
                  "content-type": "application/json",
                  "Access-Control-Allow-Origin": "*"
                }
              });
            } else if (actionType === "normalize") {
              // Удаляем все изменения для этого рейса
              delete rtData[tripId];
              await setRtData(env.kv, dateInput, rtData);
              return new Response(JSON.stringify({
                status: "ok", 
                trip_id: tripId, 
                action: "normalize",
                message: "All real-time changes cleared for this trip and date",
                date_input: dateInput,
                date_used: convertDateToYYYYMMDD(dateInput)
              }, null, 2), {
                headers: {
                  "content-type": "application/json",
                  "Access-Control-Allow-Origin": "*"
                }
              });
            }
          }

          if (actionType === "stop_time") {
            const stop_id = pathParts[7];
            const action = pathParts[8];
            const minutes = pathParts[9] ? Number(pathParts[9]) : 0;
            
            // Для действия cancel не должно быть распространения
            if (action === "cancel") {
              rtData[tripId] = rtData[tripId] || {stop_times: {}, stop_exceptions: []};
              rtData[tripId].stop_times[stop_id] = {action, minutes: 0, propagate: false};
            } else {
              // Для delay/earlify проверяем флаг only
              rtData[tripId] = rtData[tripId] || {stop_times: {}, stop_exceptions: []};
              rtData[tripId].stop_times[stop_id] = {
                action, 
                minutes, 
                propagate: !onlyFlag // Если only=true, то propagate=false, иначе propagate=true
              };
            }
            
            await setRtData(env.kv, dateInput, rtData);
            return new Response(JSON.stringify({
              status: "ok", 
              trip_id: tripId, 
              stop_id, 
              action, 
              minutes,
              propagate: action === "cancel" ? false : !onlyFlag,
              date_input: dateInput,
              date_used: convertDateToYYYYMMDD(dateInput)
            }, null, 2), {
              headers: {
                "content-type": "application/json",
                "Access-Control-Allow-Origin": "*"
              }
            });
          }

          if (actionType === "stop_exception") {
            const stop_id = pathParts[7];
            const after_stop_id = pathParts[8];
            const hhmmss = pathParts[9];
            const stop_name = decodeURIComponent(pathParts[10] || "");
            
            // Находим stop_sequence для after_stop_id
            let afterStopSequence = "";
            const stopTime = gtfs.stopTimes.find(st => st.trip_id === tripId && st.stop_id === after_stop_id);
            if (stopTime) {
              afterStopSequence = stopTime.stop_sequence;
            }
            
            rtData[tripId] = rtData[tripId] || {stop_times: {}, stop_exceptions: []};
            rtData[tripId].stop_exceptions.push({
              stop_id, 
              after_stop_id, 
              after_stop_sequence: afterStopSequence,
              time: hhmmss, 
              stop_name
            });
            
            await setRtData(env.kv, dateInput, rtData);
            return new Response(JSON.stringify({
              status: "ok", 
              trip_id: tripId, 
              stop_id, 
              after_stop_id, 
              time: hhmmss, 
              stop_name,
              date_input: dateInput,
              date_used: convertDateToYYYYMMDD(dateInput)
            }, null, 2), {
              headers: {
                "content-type": "application/json",
                "Access-Control-Allow-Origin": "*"
              }
            });
          }
        }
        
        // Добавим endpoint для проверки данных
        if (pathParts[2] === "check") {
          const dateInput = pathParts[3];
          const tripId = pathParts[4];
          const rtData = await getRtData(env.kv, dateInput);
          
          let responseData = {
            status: "ok",
            date_input: dateInput,
            date_used: convertDateToYYYYMMDD(dateInput),
            today_date: todayDate
          };
          
          if (tripId) {
            responseData.trip_data = rtData[tripId] || {};
            responseData.trip_id = tripId;
          } else {
            responseData.all_data = rtData;
          }
          
          return new Response(JSON.stringify(responseData, null, 2), {
            headers: {"content-type": "application/json", "Access-Control-Allow-Origin": "*"}
          });
        }
        
        // Добавим endpoint для очистки данных
        if (pathParts[2] === "clear") {
          const dateInput = pathParts[3];
          const tripId = pathParts[4];
          const rtData = await getRtData(env.kv, dateInput);
          
          if (tripId) {
            // Очищаем только один рейс
            if (rtData[tripId]) {
              delete rtData[tripId];
              await setRtData(env.kv, dateInput, rtData);
              return new Response(JSON.stringify({
                status: "ok",
                message: `Cleared data for trip ${tripId}`,
                date_input: dateInput,
                date_used: convertDateToYYYYMMDD(dateInput)
              }, null, 2), {
                headers: {"content-type": "application/json", "Access-Control-Allow-Origin": "*"}
              });
            } else {
              return new Response(JSON.stringify({
                status: "error",
                message: `No data found for trip ${tripId}`
              }, null, 2), {
                status: 404,
                headers: {"content-type": "application/json", "Access-Control-Allow-Origin": "*"}
              });
            }
          } else {
            // Очищаем все данные за дату
            await setRtData(env.kv, dateInput, {});
            return new Response(JSON.stringify({
              status: "ok",
              message: `Cleared all data for date ${dateInput}`,
              date_input: dateInput,
              date_used: convertDateToYYYYMMDD(dateInput)
            }, null, 2), {
              headers: {"content-type": "application/json", "Access-Control-Allow-Origin": "*"}
            });
          }
        }
      }

      // ---------------- DEFAULT ENDPOINT ----------------
      if (pathname === "") {
        return new Response(JSON.stringify({
          status: "ok",
          endpoints: {
            stop_monitoring: "/stop_monitoring/{stop_id}/[mode]?q=5",
            trips_list: "/trips",
            trip_detail: "/trips/{trip_id}/[realtime|scheduled]",
            rtedit_check: "/rtedit/{password}/check/{date}/[trip_id]",
            rtedit_clear: "/rtedit/{password}/clear/{date}/[trip_id]",
            rtedit_trip_cancel: "/rtedit/{password}/edit/{date}/trip/{trip_id}/cancel",
            rtedit_trip_normalize: "/rtedit/{password}/edit/{date}/trip/{trip_id}/normalize",
            rtedit_stop_delay: "/rtedit/{password}/edit/{date}/trip/{trip_id}/stop_time/{stop_id}/delay/{minutes}[?only=true]",
            rtedit_stop_earlify: "/rtedit/{password}/edit/{date}/trip/{trip_id}/stop_time/{stop_id}/earlify/{minutes}[?only=true]",
            rtedit_stop_cancel: "/rtedit/{password}/edit/{date}/trip/{trip_id}/stop_time/{stop_id}/cancel"
          },
          today_date: todayDate,
          now_minutes: nowMinutes,
          active_service_ids: Array.from(activeServiceIdsSet)
        }, null, 2), {
          headers: {
            "content-type": "application/json",
            "Access-Control-Allow-Origin": "*"
          }
        });
      }

      return new Response(JSON.stringify({status: "error", message: "Invalid endpoint"}, null, 2), {status:404, headers:{"content-type":"application/json"}});
    } catch(err) {
      return new Response(JSON.stringify({status: "error", message: err.message}, null, 2), {status:500, headers:{"content-type":"application/json"}});
    }
  }
};
